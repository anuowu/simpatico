<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simpatico: 4.3 Factory Classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simpatico
   &#160;<span id="projectnumber">v1.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Simpatico - Simulation Package for Polymer and Molecular Liquids</a></li><li class="navelem"><a class="el" href="extend_page.html">4 Extending Simpatico</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">4.3 Factory Classes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="extend_build_page.html">4.3 Build system</a> (Prev) &#160; &#160; &#160; &#160; <a class="el" href="extend_potential_page.html">4.4 Potential Energy Classes</a> (Next) <br />
</p>
<h1><a class="anchor" id="factory_purpose"></a>
Why Factory Classes Exist</h1>
<p>Simpatico defines a set of base classes to represent modifiable elements of a simulation, such as molecular species and simulation algorithms. The parameter file format allows users to choose at run time from among various subclasses of these bases classes, and thereby choose particular elements to use in a simulation. This is done primarily by the use of polymorhpic blocks in the parameter file. A polymorphic block is a parameter file block that may contain the file format for any known subclass of a particular base class. The desired subclass is identified by the class name in the opening line of such a block.</p>
<p>The code which parses a polymorphic block must: (1) Extract the name of the desired subclass from the opening line of the block, (2) Compare this name string to a list of known subclasses of the relevant base class, (3) Create an instance of the desired subclass if the name is recognized, or throw an Exception if it is not, and (4) Call the readParameters() method of the new object in order to read the remainder of the block. An associated Factory class implements steps (2) and (3) of this process: The recognition of the subclass name class, and the construction of an new instance of the desired class.</p>
<p>The implementation of a Factory class associated with a base class defines the set of subclasseses can be recognized in the parameter file, and that can thus be used in a simulation. Simpatico provides a Factory class for each base class that is associated with polymorphic block or blocks in the parameter file. The name of the factory class is usually given by the name of the base class followed by the word "Factory". For example, <a class="el" href="classMcMd_1_1McMoveFactory.html" title="McMoveFactory for an McSimulation. ">McMd::McMoveFactory</a> is the factory class for <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves. ">McMove</a> objects. The default factory implementation will recognize the names of any subclass that is distributed with Simpatico.</p>
<p>To allow a user-defined subclass to be included in the parameter file, the developer must thus add the new class to the list of classes that are recognized by the associated Factory. This can be done by adding a few lines to the Factory implementation (*.cpp) file, as discussed below.</p>
<p>In order to allow users to modify the factory implementation files, but to avoid changing files that are under version control, their are two versions of the implementation file for each factory. The file whose name ends with the file extension ".cpp_r" (for example, MdIntegratorFactory.cpp_r)is a default version that is stored in the git repository, but that is never actually compiled. The file whose name ends with ".cpp" (e.g., <a class="el" href="MdIntegrator_8cpp_source.html">MdIntegrator.cpp</a>) is a user version that is actually compiled and linked, but that is not stored in the repository. The initial version of each such *.cpp file is created by the "setup" script by simply copying the *.cpp_r file, when Simpatico is first setup. Users should modify the *Factory.cpp files in order to add new subclasses that are intended for their own use, and should avoid modifying the *Factory.cpp_r files. The *.cpp_r files should be modified only to add new classes that are intended to be distributed with Simpatico. After modifying one or more Factory implementation files, users must also be careful to not rerun the setup script, since this would overwrite their changes.</p>
<h1><a class="anchor" id="factory_structure_sec"></a>
factory() Methods</h1>
<p>The Factory class associated with a class named "Base" (where "Base" could be <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves. ">McMove</a>, <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators. ">MdIntegrator</a>, <a class="el" href="classMcMd_1_1Analyzer.html" title="Abstract base for periodic output and/or analysis actions. ">Analyzer</a>, etc.) is normally derived from the class template <a class="el" href="classUtil_1_1Factory.html" title="Factory template. ">Util::Factory</a> &lt; Base &gt;. For example, <a class="el" href="classMcMd_1_1McMoveFactory.html" title="McMoveFactory for an McSimulation. ">McMd::McMoveFactory</a> is derived from the template instantiation <a class="el" href="classUtil_1_1Factory.html" title="Factory template. ">Util::Factory</a> &lt; <a class="el" href="classMcMd_1_1McMove.html" title="McMove is an abstract base class for Monte Carlo moves. ">McMd::McMove</a> &gt;. The <a class="el" href="classUtil_1_1Factory.html" title="Factory template. ">Util::Factory</a> template declares a pure virtual method named factory() with the following interface. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Base&gt;</div><div class="line">Base* <a class="code" href="classUtil_1_1Factory.html#af20c43592ab1c48d9e5ed2fcdcbded81">Factory&lt;Base&gt;::factory</a>(<span class="keyword">const</span> std::string className) <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p> The function parameter className should contain the name of a subclass of Base. If the method recognizes this name, it creates a new instance of the specified subclass, and returns a Base* pointer to the new object. This pointer can then be used by the invoking function to read the associated parameter file block, by invoking the readParam() method of the new object. If the classname string is not recognized, the factory method returns a null pointer. The function that calls this method should throw an Exception if a null pointer is returned.</p>
<p>As an example, consider the class <a class="el" href="classMcMd_1_1MdIntegratorFactory.html" title="Default Factory for subclasses of MdIntegrator. ">McMd::MdIntegratorFactory</a> that is distributed with Simpatico, which is a subclass of Util::Factory&lt;McMd::MdIntegrator&gt;. Here is the default implementation of the <a class="el" href="classMcMd_1_1MdIntegratorFactory.html#a311ab329444414f294a77e629df8047a" title="Method to create any species supplied with Simpatico. ">MdIntegratorFactory::factory()</a> method: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MdIntegratorFactory.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// Subclasses of MdIntegrator </span></div><div class="line"><span class="preprocessor">#include &quot;NveIntegrator.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;NvtIntegrator.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;NvtDpdIntegrator.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceMcMd.html">McMd</a> </div><div class="line">{</div><div class="line"></div><div class="line">   MdIntegrator* <a class="code" href="classMcMd_1_1MdIntegratorFactory.html#a311ab329444414f294a77e629df8047a">MdIntegratorFactory::factory</a>(std::string &amp;className)</div><div class="line">   {</div><div class="line">      MdIntegrator *ptr = 0;</div><div class="line"></div><div class="line">      <span class="comment">// Search subfactories first (if any)</span></div><div class="line">      ptr = <a class="code" href="classUtil_1_1Factory.html#a0ed7025e8764a29d33ab446c25ae4554">trySubfactories</a>(className);</div><div class="line">      <span class="keywordflow">if</span> (ptr) <span class="keywordflow">return</span> ptr;</div><div class="line"></div><div class="line">      <span class="comment">// Try matching names of specific subclasses of MdIntegrator.</span></div><div class="line">      <span class="keywordflow">if</span> (className == <span class="stringliteral">&quot;NveVvIntegrator&quot;</span>) {</div><div class="line">         <span class="comment">// NVE Velocity-Verlet (VV)</span></div><div class="line">         ptr = <span class="keyword">new</span> NveIntegrator(*systemPtr_); </div><div class="line">      } <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">if</span> (className == <span class="stringliteral">&quot;NvtNhIntegrator&quot;</span>) {</div><div class="line">         <span class="comment">// NVT Nose-Hoover (NH)</span></div><div class="line">         ptr = <span class="keyword">new</span> NvtNhIntegrator(*systemPtr_);  </div><div class="line">      } <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">if</span> (className == <span class="stringliteral">&quot;NvtDpdIntegrator&quot;</span>) {</div><div class="line">         <span class="comment">// NVT Dissipative Particle Dynamics (DPD)</span></div><div class="line">         ptr = <span class="keyword">new</span> NvtDpdIntegrator(*systemPtr_); </div><div class="line">      }</div><div class="line">      <span class="keywordflow">return</span> ptr;</div><div class="line">   }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The relevant part of this function is a sequence of nested else-if blocks. Each if-block in this sequence compares the "className" string parameter to the name of a known subclass of <a class="el" href="classMcMd_1_1MdIntegrator.html" title="Abstract base for molecular dynamics integrators. ">MdIntegrator</a>, and creates a new object of that subclass if the name matches. To add a new subclass, a user must merely add another else-if block to this sequence, and then follow the usual instructions to recompile all relevant executables.</p>
<p>This series of else-if blocks is preceded by a pair of lines: </p><div class="fragment"><div class="line">ptr = trySubfactories(className);</div><div class="line"><span class="keywordflow">if</span> (ptr) <span class="keywordflow">return</span> ptr;</div></div><!-- fragment --><p> This pair of lines allows for the possibility that a Factory may contain one or more "subfactories". The use of more subfactories is an alternative to the modification of the default factory implementation that is described here. By default, none of the factories have any subfactories. If a factory has no subfactories, the trySubfactories() method returns a null pointer, and this pair of lines does nothing. The use of subfactories is discussed <a class="el" href="extend_subfactory_page.html">here</a>.</p>
<p><br />
 <a class="el" href="extend_build_page.html">4.3 Build system</a> (Prev) &#160; &#160; &#160; &#160; <a class="el" href="extend_page.html">4 Extending Simpatico</a> (Up) &#160; &#160; &#160; &#160; <a class="el" href="extend_potential_page.html">4.4 Potential Energy Classes</a> (Next) </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 7 2018 12:59:45 for Simpatico by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
